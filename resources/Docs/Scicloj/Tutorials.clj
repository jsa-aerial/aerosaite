[{:ed3 {:label "Template Walkthrough", :opts {:order :row, :eltsper 1, :size "auto", :wrapfn {:tid :ed3, :$split nil, :out-width "1300px", :fn [quote editor-repl-tab], :layout :left-right, :ns doc.code, :ed-out-order :first-last, :width "730px", :md-defaults nil, :src "\n;;; A walk through 'exercise' with templates, substitution keys and\n;;; transformations using them.\n\n;;; hc/xform is the general transformation function. It actually can work on ;;; any nested set of collections. Typically the outer is a map, but need not \n;;; be.\n;;; It has three signatures, one of which is variadic:\n;;; hc/xform [coll], hc/xform [coll submap], hc/xform [coll k v & kvs]\n\n;;; hc/get-default takes a key and returns its value in the default \n;;; substitution key map AKA 'submap'.  Or nil if not there\n\n;;; To execute the forms here, one by one, you can put the cursor on the outer\n;;; most right paren and use Ctrl-X Ctrl-E (like Cider eval last sexp). Or,\n;;; put the cursor somewhere in the sexp (even at the end) and use\n;;; Ctrl-X Ctrl-C (like Cider Ctrl-C Ctrl-C eval outer sexp)\n\n;;; uses only the default submap\n(hc/xform {:a :X})\n(hc/get-default :X)\n\n;;; Values given as k/v pairs override any in the default submap\n(hc/xform {:a :X} :X \"foo\")\n\n;;; Next, we first get {:a {:y :Y}}, which is then recursively transformed\n(hc/xform {:a :X} :X {:y :Y})\n(hc/get-default :Y)\n\n;;; If a value is neither in the default submap nor given as a k/v pair,\n;;; it is taken as the literal value\n(hc/xform {:a :Saite})\n(hc/get-default :Saite)\n;;; Again, giving it a value in the k/v pairs will use that value\n(hc/xform {:a :Saite} :Saite 12)\n(hc/get-default :FOO)\n(hc/xform {:a :FOO} :FOO #{1 2})\n\n;;; Here we see an example of the third transformation rule in action\n;;; (https://github.com/jsa-aerial/hanami#basic-transformation-rules)\n;;; {:a :FOO} --> {:a  #{}} --> {:a RMV} --> {}\n;;; hc/RMV is the special Specter value NONE, which when encountered\n;;; in a (Specter) transform means to remove the associated item.\n(hc/xform {:a :FOO} :FOO #{})\n\n;;; Many (most) default substitution key values are RMV. This is so the key\n;;; they are a value for will be removed from anywhere they appear, unless\n;;; a specific value is given for them.\n;;; {:a :FOO} --> {:a {:scale :XSCALE}} --> {:a {:scale RMV}} -->\n;;; {:a {}} --> {:a RMV} --> {}\n(hc/get-default :XSCALE)\n(hc/xform {:a :FOO} :FOO {:scale :XSCALE})\n\n;;; We can use the default data template fragment to show this basic idea in\n;;; action. The fragment has 4 items:\nht/data-options\n;;; Three of the associated substitution keys default to RMV\n(hc/get-default :NDATA)\n(hc/get-default :UDATA)\n(hc/get-default :DFMT)\n\n;;; :VALDATA is an interesting case as its default value is a function\n;;; (//github.com/jsa-aerial/hanami#function-values-for-substitution-keys)\n;;; This function looks up :FDATA and :DATA in the current submap passed to\n;;; it. If they are RMV, it returns RMV. hc/_defaults is the default submap.\n(hc/get-default :VALDATA)\n(hc/get-default :DATA)\n(hc/get-default :FDATA)\n((hc/get-default :VALDATA) @hc/_defaults)\n;;; If :DATA has a value it returns that.\n((hc/get-default :VALDATA) {:DATA [{\"one\" 1} {\"two\" 2} {\"three\" 3}]})\n\n;;; ON SERVER SIDE ONLY: If :FDATA has a value the :VALDATA function looks up \n;;; :FDATA's substitution key function\n;;; (https://github.com/jsa-aerial/hanami#subtitution-key-functions) and\n;;; passes it the value of :FDATA, and the current submap. This function will\n;;; resolve the value of :FDATA to a file (or error) and fetch its content.\n;;; On the client this always returns RMV. Place cursor at right paren.\n;;; Ctrl-X Ctrl-E runs on client. Ctrl-X J runs on server (will give file\n;;; not found error - unless you have a real json file there...)\n((hc/get-default :VALDATA)\n (merge @hc/_defaults {:FDATA \"~/.saite/Data/my-data.json\"}))\n\n\n;;; OK, after that diversion, back to how the third rule of xform and having\n;;; RMV for most defaults works in our favor in getting legal VG/VGL field\n;;; values while using very generic fragments in definitions. So, we can now\n;;; see that with just the defaults, all four items in data-options will\n;;; get RMV and so all four will be removed:\nht/data-options\n(hc/xform ht/data-options)\n;;; But if we give one a legal value we get a legal data field value\n(hc/xform ht/data-options :DATA [{\"one\" 1} {\"two\" 2} {\"three\" 3}])\n(hc/xform ht/data-options :UDATA \"data/cars.json\")\n;;; Yes, if you give more than one, you will get an ILLEGAL value. But then\n;;; you deserve what you get...\n\n\n;;; Because of this, we can just use hc/data-options as the default value of\n;;; the data field in a view (see Vega/Vega-Lite for information on views)\n;;; view-base is a fragment that is used in the definition of any view in\n;;; templates.\nht/view-base\n\n;;; As you see, there is a lot of stuff and most of it substitution keys which\n;;; themselves have a lot of stuff. Take :ENCODING for example\n(hc/get-default :ENCODING)\n\n;;; Again, a lot of stuff, most of it more substitution keys. But we are\n;;; bottoming out - _most_ of these have base values - many RMV. If we\n;;; transform this using just the defaults, we get a legal (default) encoding\n(hc/xform {:encoding :ENCODING})\n\n\n;;; Let's look at another pair in view-base, the :usermeta :USERDATA pair\n;;; The :usermeta field is a special field that the authors of VG/VGL (the\n;;; members of the Interactive Data Lab at UWash in Seattle) have included in\n;;; the schemas of VG and VGL. They understood user apps may want to encode\n;;; special data in a legal VG/VGL spec and this field supports that use\n;;; case. Generally, that data will be some form of _control_ data. That's\n;;; exactly how it is used in Saite. Out of the box, Hanami has :USERDATA\n;;; as RMV, so :usermeta will just be removed. But Saite gives it a value of\n;;; various control data.\n(hc/get-default :USERDATA)\n\n;;; Again, many values are substitution keys themselves with their own default\n;;; values.  :msgop and :session-name are really server things and don't\n;;; concern us when working via the client.  In the 'Tabs' tab and 'Gallery'\n;;; tab of this document, you will see values given for :LEFT, :TOP, :FID, :VID\n;;; which control how the associated picture frame and vis are displayed.\n(hc/xform (hc/get-default :USERDATA))\n\n\n;;; Now that we've seen :ENCODING and :USERDATA, let's go back to view-base and\n;;; see how these work to give a nearly complete Vega-Lite specification when\n;;; transformed. Put the cursor at the 'e' in view-base and Ctrl-X Ctrl-E to\n;;; get its value. Then use Ctrl-X Ctrl-C to get the transformed value.\n(hc/xform ht/view-base)\n;;; That's pretty close to being a legal view spec, but it doesn't have a data\n;;; value and so would throw an error in VGL. We can fix that by giving a\n;;; data source\n(hc/xform ht/view-base :UDATA \"data/cars.json\")\n\n;;; OK, the only thing left to get a legal spec is to add in a mark spec. Marks\n;;; basically define how VG/VGL render the view - line plot, scatter plot, bar\n;;; chart, area chart, etc etc. There are several out-of-box 'chart/plot'\n;;; templates that add a mark around view-base. Here are a couple. Put the\n;;; cursor at the end and Ctrl-X Ctrl-E. Notice the mark spec again has several\n;;; fields with substitution key values. Only the 'type' field is concrete.\nht/point-chart\nht/bar-chart\n\n;;; Now we are ready to get a complete legal Vega-Lite specification. We will\n;;; use the point-chart template which will give a scatter plot. So, we need\n;;; a data source and this one has it's x field as the string \"Horsepower\" and\n;;; its y field as \"Miles_per_Gallon\". That's all we really need, but to get\n;;; a nice color faceting, we also ask the \"Origin\" field be color faceted.\n;;; You can see this exact chart rendered in the 'Tabs' tab demo (where we\n;;; add frame and visual ids to control its placement in the doc body)\n(hc/xform\n ht/point-chart\n :UDATA \"data/cars.json\"\n :X \"Horsepower\" :Y \"Miles_per_Gallon\" :COLOR \"Origin\")\n\n\n;;; We are pretty much at the end here. The last thing to cover concerns what\n;;; some have voiced a desire for - changing the default style of using\n;;; :UPPERCASE keywords for substitution keys. Nothing in any of the\n;;; transformation process requires this and you can make them be any style\n;;; or form you like. The following is a little exercise in how you can\n;;; automate that change\n;;; We already saw that hc/_defaults is the default submap. As you can see,\n;;; there are a lot of such default keys.\n(deref hc/_defaults)\n;;; We will need clojure.set and clojure.string for the exercise. Like any\n;;; form, requires can be evaluated. Just put the cursor on the right paren\n;;; like any other example, and Ctrl-X Ctrl-E these\n(require '[clojure.set :as set])\n(require '[clojure.string :as str])\n;;; We will turn our uppercase keys into lower case strings. mydefs is a map\n;;; from the uppercase keywords to their lower case strings. If you eval this\n;;; you will see the first (random) 10 cases. Comment the take out and\n;;; uncomment each xform in turn to see how the templates can be transformed\n;;; to use these lower case substitution keys.\n;;; This is just an example, more likely version would use namespace qualified\n;;; lowercase keywords.\n(let [mydefs (->> hc/_defaults deref\n               (mapv (fn[[k v]](vector (-> k name str/lower-case) k)))\n               (into {}) set/map-invert)]\n  (take 10 mydefs)\n  ;; Convert the current default substitution _keys_ to be our new lowercase\n  ;; string keys. You could then reset! hc/_defaults to this map to a merge of\n  ;; it with the default hc/_defaults to have both types of keys.\n  #_(hc/xform @hc/_defaults mydefs)\n  ;; Use it to perform same conversion of view-base and point-chart as above\n  #_(hc/xform ht/view-base (hc/xform @hc/_defaults mydefs))\n  #_(hc/xform ht/point-chart (hc/xform @hc/_defaults mydefs)))", :out-height "900px", :eid "ed-ed3", :height "900px"}}, :specs []}} {:chap3 {:label "VGL->Picframe", :opts {:order :row, :eltsper 1, :rgap "20px", :cgap "20px", :size "auto", :wrapfn {:tid :chap3, :$split 39.16015625, :out-width "730px", :fn [quote interactive-doc-tab], :cmfids {:cm 0, :fm 0}, :ns doc.code, :ed-out-order :first-last, :width "730px", :md-defaults nil, :src "\n\n\n(count (range -100.0 100.0 0.5))\n\n(take 10 (range -100.0 100.0 0.5))\n(take-last 10 (range -100.0 100.0 0.5))\n\n\n\n(def dataset\n  (->>\n  (range -100.0 100.0 0.5)\n  (mapv #(vector % %))\n  (mapv (fn[[x y]] {:x x :y y}))))\n\n\n\n\n;;; A simple Vega-Lite spec for line chart visualization\n;;;{\n;;;  \"data\": {\"values\": []},\n;;;  \"mark\": \"line\",\n;;;  \"encoding\": {\n;;;    \"x\": {\"field\": \"x\", \"type\": \"quantitative\"},\n;;;    \"y\": {\"field\": \"y\", \"type\": \"quantitative\"}\n;;;  }\n;;;}\n\n\n\n\n\n\n\n\n(def chart\n  {:usermeta (hc/get-default :USERDATA)\n   :data {:values dataset},\n   :mark \"line\",\n   :encoding\n   {:x {:field \"x\", :type \"quantitative\"},\n    :y {:field \"y\", :type \"quantitative\"}}})\n\n\n\n\n\n\n\n\n\n\n(-> (hc/xform\n     chart :TID :charts :FID :f1 :VID :v1)\n  hmi/sv!)\n\n\n\n\n\n\n(hc/xform\n chart :TID :charts :FID :f1 :VID :v1)\n\n\n\n\n\n\n\n(hc/xform\n ht/line-chart :FID :f2 :VID :v2\n :DATA dataset)\n\n;;; change data to x^2\n;;; (mapv (fn[m] (assoc m :y (let [x (m :x)] (* x x))))dataset)\n;;; Add :TITLE \"y = x^2\"\n;;; Add :YTITLE \"x^2\"\n;;; Add :TOP `[[md \" \\\\(f(x) = x^2\\\\)\"]]\n;;; Add {:style {:font-size \"16px\"}}\n;;; Change :TOP to :BOTTOM\n;;; Add [gap :size \"220px\"] component", :out-height "100px", :eid "ed-chap3", :height "790px"}}, :specs []}}]
