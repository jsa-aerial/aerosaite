[{:ed2 {:label "Uncomplicate", :opts {:order :row, :eltsper 1, :size "auto", :wrapfn {:tid :ed2, :$split nil, :out-width "1300px", :fn [quote editor-repl-tab], :layout :left-right, :ns doc.code, :ed-out-order :first-last, :width "730px", :md-defaults nil, :src "(System/getenv \"LD_LIBRARY_PATH\")\n\n;;; All of this is must run on the JVM.  So, use Ctrl-X J (with cursor at\n;;; end right paren) or Ctrl-X Ctrl-J with curso inside a form\n\n;;; Dependencies and resource requires and imports\n;;;\n(deps '[[uncomplicate/neanderthal \"0.39.0\"]\n        [criterium \"0.4.4\"]])\n\n;;; Apple is terrible.  They constantly are breaking things so we need this\n;;; now for Macs\n#_(deps '[[uncomplicate/neanderthal \"0.39.0\"\n         :exclusions \n         [[org.jcuda/jcuda-natives :classifier \"apple-x86_64\"]\n          [org.jcuda/jcublas-natives :classifier \"apple-x86_64\"]]]\n        [criterium \"0.4.4\"]])\n\n\n(require '[uncomplicate.commons.core\n           :refer [with-release let-release\n                   Releaseable release]]\n         '[uncomplicate.fluokitten.core :refer [fmap!]]\n         '[uncomplicate.neanderthal\n           [native :refer [dv dge fge dtr native-float]]\n           [core :refer [copy copy! mv! mv axpy! scal! transfer! submatrix\n                         transfer! transfer mrows ncols nrm2 mm cols view-tr]]\n           [real :refer [entry entry!]]\n           [math :refer [signum exp]]\n           [linalg :refer [trf tri det]]\n           [vect-math :refer [fmax! tanh! linear-frac!]]])\n\n(import clojure.lang.IFn)\n\n\n\n;;; Code examples\n;;;\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               h1 (dv 4)]\n   (mv! w1 x h1))\n\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               h1 (dv 4)\n               w2 (dge 1 4 [0.75 0.15 0.22 0.33])\n               y (dv 1)]\n   (mv! w2 (mv! w1 x h1) y))\n\n\n(defn step! [threshold x]\n  (fmap! signum (axpy! -1.0 threshold (fmax! threshold x x))))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               threshold (dv 0.7 0.2 1.1 2)]\n  (step! threshold (mv w1 x)))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)\n               zero (dv 4)]\n  (step! zero (axpy! -1.0 bias (mv w1 x))))\n;;; bias is same as threshold. No need for extra zero vector\n;;; ==\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (step! bias (mv w1 x)))\n\n\n;;; Activation Functions\n\n(defn relu! [threshold x]\n  (axpy! -1.0 threshold (fmax! threshold x x)))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (relu! bias (mv w1 x)))\n\n;;; tanh is directly available in vect-math\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (tanh! (axpy! -1.0 bias (mv w1 x))))\n\n;;; sigmoid S(x) = 1/2 + (1/2 * tanh(x/2))\n(defn sigmoid! [x]\n  (linear-frac! 0.5 (tanh! (scal! 0.5 x)) 0.5))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (sigmoid! (axpy! -1.0 bias (mv w1 x))))\n\n\n;;; Manually stacking with tanh and sigmoid\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias1 (dv 0.7 0.2 1.1 2)\n               h1 (dv 4)\n               w2 (dge 1 4 [0.75 0.15 0.22 0.33])\n               bias2 (dv 0.3)\n               y (dv 1)]\n  (tanh! (axpy! -1.0 bias1 (mv! w1 x h1)))\n  (sigmoid! (axpy! -1.0 bias2 (mv! w2 h1 y))))\n\n\n\n\n\n(let [a (dge 2 3 (range 6))\n      b (submatrix a 0 1 1 2)]\n  (scal! 100 b)\n  a)\n\n(let [a (dge 3 2 (range 6))\n      b (dge 3 2)]\n  (copy! a b)\n  (entry! a 1 1 800)\n  (copy b))\n\n(let [a (dge 3 2)]\n  (transfer! (list 1 2 3 4 5 6) a))\n\n(let [a (dge 3 2 (range 6) {:layout :row})]\n  (seq (transfer! a (double-array (* (mrows a) (ncols a))))))\n\n(with-release [a (dtr 3 (range 1 7) {:layout :row :diag :unit :uplo :lower})\n               b (dge 3 4 (range 1 13))]\n  (mm a b))\n\n(dtr 3 (range 1 7) {:layout :row :diag :unit :uplo :lower})\n\n(def lu (trf (dge 3 3 [1 0 -1 3 -2 3 4 1 1] {:layout :column})))\n(view-tr (:lu lu) {:uplo :lower :diag :unit})\n(view-tr (:lu lu) {:uplo :upper})\n(det lu)\n(mm  (tri lu) (dge 3 3 [1 0 -1 3 -2 3 4 1 1] {:layout :column}))\n(tri lu)\n\n;;; ======================================================================= ;;;\n;;;                    Part 3 - automate stacking.\n;;; ======================================================================= ;;;\n\n(defprotocol Parameters\n  (weights [this])\n  (bias [this]))\n\n;;; Implements release method of Releasable protocol and the invoke\n;;; method of IFn. Includes parameters `w' weights `b' biases\n(deftype FullyConnectedInference [w b h activ-fn]\n  Releaseable\n  (release [_]\n    (release w)\n    (release b)\n    (release h))\n  Parameters\n  (weights [this] w)\n  (bias [this] b)\n  IFn\n  (invoke [_ x]\n    (activ-fn b (mv! w x h))))\n\n;;; Constructor for inference layer\n(defn fully-connected [activ-fn in-dim out-dim]\n  (let-release [w (dge out-dim in-dim)\n                bias (dv out-dim)\n                h (dv out-dim)]\n    (->FullyConnectedInference w bias h activ-fn)))\n\n\n;;; Bias versions of sigmoid and tanh\n(defn activ-sigmoid! [bias x]\n  (axpy! -1.0 bias x)\n  (linear-frac! 0.5 (tanh! (scal! 0.5 x)) 0.5))\n\n(defn activ-tanh! [bias x]\n  (tanh! (axpy! -1.0 bias x)))\n\n\n\n:end", :out-height "900px", :eid "ed-ed2", :height "900px"}}, :specs []}} {:kixs {:label "Kixistats", :opts {:order :row, :eltsper 1, :size "auto", :wrapfn {:tid :kixs, :$split nil, :out-width "730px", :fn [quote editor-repl-tab], :layout :left-right, :ns doc.code, :ed-out-order :first-last, :width "730px", :md-defaults nil, :src ";;; All of this is must run on the JVM.  So, use Ctrl-X J (with cursor at\n;;; end right paren) or Ctrl-X Ctrl-J with curso inside a form\n\n(deps '[[kixi/stats \"0.5.4\"]])\n\n(require '[kixi.stats.core\n           :as ks\n           :refer [mean median standard-deviation correlation]]\n         '[kixi.stats.distribution :as kd]\n         '[redux.core :refer [fuse]])\n\n(->> [{:x 2} {:x 4} {:x 4} {:x 4} {:x 5} {:x 5} {:x 5} {:x 7} {:x 9}]\n     (transduce (map :x) standard-deviation))\n\n(->>  [{:x 1 :y 3} {:x 2 :y 2} {:x 3 :y 1}]\n      (transduce identity (correlation :x :y)))\n\n(->> [{:x 1 :y 3 :z 2} {:x 2 :y 2 :z 4} {:x 3 :y 1 :z 6}]\n     (transduce identity (ks/correlation-matrix {:x :x :y :y :z :z})))\n\n(->> [2 4 4 4 5 5 5 7 9]\n     (transduce identity (fuse {:mean mean :sd standard-deviation})))\n\n;;; Calculate the median only of numbers greater than 5:\n(def gt5? (filter #(> % 5)))\n(transduce gt5? median (range 10))\n\n;; Count both all numbers and those greater than 5:\n(transduce identity (fuse {:n ks/count :gt5 (gt5? ks/count)}) (range 10))\n\n;; Calculate the median, iqr and 5-number summary:\n(->> (range 100)\n     (transduce identity (fuse {:median median\n                                :iqr ks/iqr\n                                :summary ks/summary})))\n\n;; Calculate the 2.5 and 97.5 quantile from an empirical distribution\n(def distribution\n  (->> (range 100)\n    (transduce identity ks/histogram)))\n\n{:lower (kd/quantile distribution 0.025)\n :upper (kd/quantile distribution 0.975)}\n\n\n;;; The post-complete function defined in the kixi.stats.core allows us to\n;;; chain the histogram and quantile steps like so:\n;;;\n;;; Calculate the 2.5 and 97.5 quantile from an empirical disribution\n\n(->> (range 100)\n     (transduce identity (ks/post-complete ks/histogram\n                           (fn [hist]\n                             {:lower (kd/quantile hist 0.025)\n                              :upper (kd/quantile hist 0.975)}))))\n\n\n\n\n;;; Distribution sampling\n;;;\n;;; kixi.stats.distribution contains functions for specifying and sampling from\n;;; statistical distributions.\n\n(kd/draw (kd/binomial {:n 100 :p 0.5}))\n(kd/sample 10 (kd/binomial {:n 100 :p 0.5}))\n\n\n\n\n;;; Discrete summarisation\n;;;\n;;; The Bernoulli, binomial and categorical distributions are discrete, so\n;;; samples can be summarised by counting the number of times each variate \n;;; appears. Discrete distributions can be directly sampled in this way with \n;;; sample-summary:\n\n(require '[kixi.stats.distribution :refer [sample-summary bernoulli]])\n\n(kd/sample-summary 1000 (kd/bernoulli {:p 0.3}))\n(kd/sample-summary 1000 (kd/binomial {:n 100 :p 0.5}))\n\n;;; Visualize in a new tab.  Use Ctrl-X Ctrl-C here. It will run the data\n;;; computation on the server and then pass to client visualizer hmi/sv!\n(let [data (clj (mapv (fn[[x y]] {:x x :y y})\n                   (kd/sample-summary 1000 (kd/binomial {:n 100 :p 0.5}))))]\n  (->\n    (hc/xform\n     ht/bar-chart :TID :ksvis\n     :DATA data)\n    hmi/sv!))\n\n\n\n\n;;; Deterministic sampling\n;;;\n;;; The sampling functions draw, sample and sample-summary are all designed to \n;;; perform deterministically when provided with a seed value. If repeatable \n;;; samples are desired, pass {:seed SEED_LONG} as the final argument:\n\n(require '[kixi.stats.distribution :refer [uniform]])\n\n(kd/draw (kd/uniform {:a 0 :b 1}) {:seed 42})\n(kd/draw (kd/uniform {:a 0 :b 1}) {:seed 42})\n(kd/draw (kd/uniform {:a 0 :b 1}))\n\n\n\n\n;;; Statistical tests\n;;;\n;;; The kixi.stats.test namespace contains functions for performing statistical\n;;; tests.\n;;;\n;;; For example, we can perform a z-test between a known population mean & \n;;; standard deviation and a sampled mean with a given sample size in the \n;;; following way:\n(require '[kixi.stats.test :as kt])\n\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}))\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}) :<>)\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}) :<)\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}) :>)\n\n;;; As with the kixi.stats.distribution namespace - which contains many \n;;; functions which mirror kixi.stats.core - simple-z-test is also available in \n;;; kixi.stats.core. The latter function returns a reducing function for use \n;;; with transduce.\n;;;\n;; If the standard deviation is not provided, the sample standard deviation \n;;; will be used instead (a 'plug-in test')\n(kt/p-value(transduce identity (ks/simple-z-test {:mu 100}) (range 200)))\n\n\n:end", :out-height "700px", :eid "ed-kixs", :height "700px"}}, :specs []}}]
